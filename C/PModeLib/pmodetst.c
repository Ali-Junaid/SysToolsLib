/*****************************************************************************\
*                                                                             *
*   File name:	    PMODETST.C						      *
*									      *
*   Description:    Test the PMODE.LIB library				      *
*									      *
*   Notes:								      *
*									      *
*   History:								      *
*    1995-02-07 JFL Jean-François LARVOIRE created this file.		      *
*    2015-10-28 JFL Removed routine _fmemmove, now in nodoslib.		      *
*									      *
*      (c) Copyright 1995-2017 Hewlett Packard Enterprise Development LP      *
* Licensed under the Apache 2.0 license - www.apache.org/licenses/LICENSE-2.0 *
\*****************************************************************************/

#include "clibdef.h"
#include "utildef.h"
#include "lodos.h"
#include "pmode.h"

/* Forward references */
void wait_x15us(int nloops);
void set_block(WORD, WORD);		// Set a DOS memory block size
void dos_exit(BYTE retcode);		// Exit to DOS using int 21H
void dump(char *pc, int len);
#define PERLINE 0x10			// Number of bytes dumped per line
#define TODUMP (10*PERLINE)		 // Number of bytes to dump

char buf0[TODUMP];
union
    {
    unsigned long ul;
    unsigned short us[2];
    unsigned char uc[4];
    } dump_addr;
int dump_len;

/* Callback routine for use with RM2PMAndCallBack. */

WORD _cdecl MyCallBack(PDESCRIPTOR pGDT, WORD wParam)
{
    char far *fpc;
    int i;

    pGDT[3].Limit_0_15 = 0xFFFF;
    pGDT[3].Base_0_15 = 0;
    pGDT[3].Base_16_23 = 0xFF;
    pGDT[3].Access_Rights = R_Data_Type;
    pGDT[3].Extra_Rights = 0;
    pGDT[3].Base_24_31 = 0xFF;

    fpc = (char far *)0x00180000L;

    for (i=0; i<TODUMP; i++) buf0[i] = *(fpc++);

    return 0;
}

/*
   Callback routine for use with RM2PMAndCallBack.
   This callback could be identical to the previous one.
   The differences are:
    - The _cdecl modifier. It could be changed to _fastcall, but this would
	require a cast in the call to VCPI2PMAndCallBack.
    - The target address is variable. It cannot be FFFF0000 since the latter
	is not mapped by VCPI in the linear address space.
    - The pagination unit management.
*/

#pragma warning(disable:4704)	// Ignore the inline assembler etc... warning

WORD _cdecl MyVCPICallBack(PDESCRIPTOR pGDT, WORD wParam)
{
    char far *fpc;
    int i;

    pGDT[3].Limit_0_15 = 0xFFFF;
    pGDT[3].Base_0_15 = dump_addr.us[0];
    pGDT[3].Base_16_23 = dump_addr.uc[2];
    pGDT[3].Access_Rights = R_Data_Type;
    pGDT[3].Extra_Rights = 0;
    pGDT[3].Base_24_31 = dump_addr.uc[3];

    fpc = (char far *)0x00180000L;

    PAGINATION_OFF;

    for (i=0; i<dump_len; i++) buf0[i] = *(fpc++);

    PAGINATION_ON;

    return 0;
}

WORD _cdecl MyVCPIRMCallBack(WORD wParm)
{
    char far *fpc;
    int i;

    fpc = (char far *)0xF000FFF0L;

    for (i=0; i<dump_len; i++) buf0[i] = *(fpc++);

    return 0;
}

/*
    32 bits Ring 0 callback.
    Must be entirely in assembly language, since the code generated by the C
     compiler is not 32 bits compatible.
    Must use the _pascal calling convention, because of contraints with the
     processor when doing inter-priviledge-level task switches.
    Immediate constants generated by the inline assembler must be extended to
     32 bits with a DW() macro.
*/

DWORD _pascal MyRing0CallBack(DWORD dwParm)
    {
    _asm mov ax, 5678H
    DW(0x1234)
    _asm leave
    _asm retf 4
    DW(0)
#pragma warning(disable:4035)	// Ignore the no return value warning
    }
#pragma warning(default:4035)

#pragma warning(default:4704)

//+--------------------------------------------------------------------------
//+ Function   : cmain
//+
//+ Purpose    : Main C routine for a mini .COM program
//+
//+ Ouput      : 0 = Success
//+		 >0 = Return value to the BIOS
//+
//+ Notes:     : Tests the PMODE library
//+
//+ Creation   : 1995/02/07 by Jean-Francois LARVOIRE
//+
//+ Modification History:
//+ Date         Author  Description
//+ -----------  ------  ----------------------------------------------------
//+
//+--------------------------------------------------------------------------

int _cdecl cmain()
{
    int err;
    int processor;
    char buf[TODUMP];
    WORD wRet;

    // Release to DOS memory beyond the 64 K we use.
    _dos_setblock(0x1000, _psp, &err);

    // Identify the processor to know beforehand what norms are supported
    processor = identify_processor();
    printf("\nThe processor is a 80%d.\n", (processor*100)+86);

    /* If a DPMI server is present, attempts to dump the GDT */

    if (processor >= 2)     /* DPMI functions require a 286 */
	{
	err = dpmi_detect();
	if (!err)
	    {
	    WORD MySel;
	    WORD LdtSel;

	    printf("\nDPMI server detected.\n");

	    dump_addr.ul = _sgdt();
	    printf("\nGDT base at %04X%04X\n",
			dump_addr.us[1], dump_addr.us[0]);

	    err = dpmi2prot();
	    if (err)
		{
		printf("\nError %d switching to protected mode using DPMI.\n",
			err);
		exit(0);
		}

	    printf("\nNow running in protected mode.\n");
	    MySel = AllocSelector(GetDS()); // Clone our DGROUP selector
	    err = !SetSelectorBase(MySel, dump_addr.ul);
	    err |= SetSelectorLimit(MySel, 0xFFFF);
	    if (!err)
		{
		_fmemmove(buf, (char far *)((DWORD)MySel << 16), TODUMP);
		printf("\nFirst %d GDT bytes:\n", TODUMP);
		dump(buf, TODUMP);
		FreeSelector(MySel);

		LdtSel = GetLDTSelfDesc();
		dump_addr.ul = GetSelectorBase(LdtSel);
		printf("\nLDT (%04X) base at %04X%04X\n", _sldt(),
			dump_addr.us[1], dump_addr.us[0]);

		_fmemmove(buf, (char far *)((DWORD)LdtSel << 16), TODUMP);
		printf("\nFirst %d LDT bytes:\n", TODUMP);
		dump(buf, TODUMP);

		dump_addr.ul = PM2Ring0AndCallBack(MyRing0CallBack, 0);
		if (dump_addr.ul == -1)
		    printf("\nFailed to switch to Ring 0.\n");
		else
		    printf("\nReturned %04X%04X from Ring 0.\n",
			    dump_addr.us[1], dump_addr.us[0]);
		}
	    else    /* This is your fate on Windows NT */
		{
		printf("\n\
Error: The DPMI server won't let us access the GDT!\n");
		}

	    _dos_exit(0);    /* Exit to DOS to return to Virtual 86 mode */
	    }
	else
	    {
	    printf("\nNo DPMI server available.\n");
	    }
	}

    /* If a VCPI server is present, prove that it replaces the reset vector */

    if (processor >= 3)     /* VCPI functions require a 386 */
	{
	err = vcpi_detect();
	if (!err)
	    {
	    printf("\nVCPI server detected.\n");

	    printf("\n\
VCPI servers usually replace the reset vector at the top of the BIOS. Proof:\n\
");

	    /* First dump the top paragraph of the BIOS in Virtual 86 mode */
	    printf("\nRead in V86 Mode at F000:FFF0:\n");
	    dump_len = PERLINE;
	    _fmemmove(buf, (char far *)0xF000FFF0L, dump_len);
	    dump(buf, dump_len);

	    /* Then dump the same paragraph in real mode */
	    err = VCPI2RMAndCallBack(MyVCPIRMCallBack, 0, &wRet);
	    if (err)
		{
		vcpi_cleanup(); // We won't use VCPI anymore.
		printf("\nVCPI Error %x switching to RM.\n", err);
		exit(0);
		}
	    if (wRet)
		{
		printf("\nThe VCPI RM callback returns error 0x%04X.\n", wRet);
		exit(0);
		}
	    printf("\nRead in RM at F000:FFF0:\n");
	    dump(buf0, dump_len);

	    /* Finally dump its other image at 4 GB - 16 bytes, in prot. mode */
	    dump_addr.ul = 0xFFFFFFF0L;
	    err = VCPI2PMAndCallBack(MyVCPICallBack, 0, &wRet);
	    if (err)
		{
		vcpi_cleanup(); // We won't use VCPI anymore.
		printf("\nVCPI Error %x switching to PM.\n", err);
		exit(0);
		}
	    if (wRet)
		{
		printf("\nThe VCPI PM callback returns error 0x%04X.\n", wRet);
		exit(0);
		}
	    printf("\nRead in PM at FFFFFFF0:\n");
	    dump(buf0, dump_len);

	    vcpi_cleanup(); // We won't use VCPI anymore.

	    exit(0);
	    }
	else
	    {
	    printf("\nNo VCPI server available.\n");
	    }
	}

    /* Else running in real mode. Dump the BIOS high memory image */

    printf("\nThe system is in real mode.\n");

    if (processor >= 3)     /* Coming back to real mode requires a 386 */
	{
	printf("\nRead in RM at F000:0000.\n");
	_fmemmove(buf, (char far *)0xF0000000L, TODUMP);
	dump(buf, TODUMP);
	err = RM2PMAndCallBack(MyCallBack, 0, &wRet);
	if (err)
	    {
	    printf("\nFailed to switch to Protected Mode. A20 gate error.\n");
	    exit(0);
	    }
	if (wRet)
	    {
	    printf("\nThe PM callback returns error 0x%04X.\n", wRet);
	    exit(0);
	    }
	printf("\nRead in PM at FFFF0000H.\n");
	dump(buf0, TODUMP);
	}

    return 0;
}

//+--------------------------------------------------------------------------
//+ Function   : dump
//+
//+ Purpose    : Dump a block of memory on screen
//+
//+ Ouput      : None
//+
//+ Notes:     :
//+
//+ Creation   : 1995/02/10 by Jean-Francois LARVOIRE
//+
//+ Modification History:
//+ Date         Author  Description
//+ -----------  ------  ----------------------------------------------------
//+
//+--------------------------------------------------------------------------

void dump(char *buf, int len)
{
    int i, j;
    char c;

    for (i=0; i<len; i+=PERLINE)
    {
	printf("%04X  ", i);

	for (j=0; (j<PERLINE) && ((i+j)<len); j++)
	{
	    if (!(j & 3)) printf(" ");
	    printf("%02X ", buf[i+j]);
	}
	printf(" ");
	for (j=0; (j<PERLINE) && ((i+j)<len); j++)
	{
	    if (!(j & 3)) printf(" ");
	    c = buf[i+j];
	    if (c < ' ') c = '.';
	    printf("%c", c);
	}
	printf("\n");
    }
}

void wait_x15us(int nloops)
{
    while (nloops--) wait_refresh();
}

void DumpSelector(WORD sel)
    {
    WORD wLdtSel;
    LPDESCRIPTOR lpLDT;
    int i;
    BYTE far *lpb;

    wLdtSel = GetLDTSelfDesc(); 	    // Get a selector into the LDT
    printf("Sel = %04X ; Desc =", sel);

    lpLDT = (LPDESCRIPTOR)((DWORD)wLdtSel << 16);  // C pointer to the LDT
    lpb = (BYTE far *)(lpLDT + (sel >> 3));
    for (i=0; i<8; i++) printf(" %02X", lpb[i]);
    printf("\n");
    }
